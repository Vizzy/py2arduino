#!/usr/bin/env python3.3

import ast, os, subprocess
from inspect import signature
from argparse import ArgumentParser
from warnings import warn, simplefilter

import ardlib

MESSAGE = '''/* 
 * This code has been auto-generated by pyduino from a Python-like source.
 * Please see https://github.com/Vizzy/pyduino for details.
 * (c) Anton Osten 
 */'''

VAR_NEW = '{indent}{type} {name} = {value}'
VAR_REDEFINED = '{indent}{name} = {value}'
AUG_ASSIGN = '{indent}{name} {op}= {value}'
FUNC_DEF = '{type} {name}({args})'
FUNC_CALL = '{indent}{name}({args})'
BIN_OP = '{indent}{left} {op} {right}'
CMPOP = '{left} {cmpop} {comparator}'
IF = '{indent}if ({test})'
WHILE = '{indent}while ({test})'

types = {
    'int': 'int',
    'float': 'float',
    'str': 'char',
    'bool': 'boolean',
    'None': 'void',
    'NoneType': 'void',
    '_empty': 'void'
}

# supported container types
container_types = (tuple, list)

funcs = {}

for attr in dir(ardlib):
    # somehow this is the only way to check if something's a function in Python
    live_attr = eval('ardlib.' + attr)
    if type(live_attr) is type(lambda x: x):
        func_name = attr
        func_type = signature(live_attr).return_annotation.__name__
        funcs[func_name] = types[func_type]

result_template = {
            'variables': {'global': {}, 'local': {}, 
                            'pending_globals': set()},
            'funcs': funcs,
            'code': ''
}


MAKE_STRUCTURE = '''CODE_DIR = {sketch_folder}
BOARD_TAG = {board}
ARDUINO_PORT = {port}
CPPFLAGS = -std=c++11
include $(ARDMK_DIR)/arduino-mk/Arduino.mk'''

class CompilationError(Exception):
    def __init__(self, message, line):
        self.message = message
        self.line = line

    def __str__(self):
        return '{} (line {})'.format(self.message, self.line)

class UnsupportedSyntaxError(CompilationError):
    pass

class ContainerTypeError(CompilationError):
    pass

class UndeclaredFunctionWarning(Warning):
    pass

def unsupported_syntax(message, line):
    raise UnsupportedSyntaxError(message, line)

calc_indent = lambda obj: ' ' * obj.col_offset

def get_arduino_type(value):
    valtype = type(value)

    if valtype is str:
        # get rid of the quotes
        value = value.replace("'", '')
        value = value.replace('"', '')

        if len(value) is 1:
            return 'char'
        else:
            return 'char *'

    elif isinstance(valtype, container_types):
        container_elts_type = get_container_elts_type(value)
        if isinstance(valtype, list):
            container_type = 'List<{}>'.format(container_elts_type)
        elif isinstance(valtype, tuple):
            container_type = 'Tuple<{}>'.format(container_elts_type)
    try:
        return types[valtype.__name__]
    except KeyError:
        raise TypeError('Type {} is not yet supported'.format(
            valtype.__name__))

def get_container_elts_type(container):
    if len(container) is 0:
        return None

    container_type = type(container[0])

    # check that all the elements are of the same type
    for elt in container:
        if type(elt) is not container_type:
            raise TypeError
    else:
        return get_arduino_type(container[0])

def get_binop_type(binop, result):
    '''This function takes an ast.BinOp object
    and the dictionary of processed code so far
    and will attempt to deduce the type of the result'''

def get_operator(op):
    if isinstance(op, ast.Add):
        return '+'

    if isinstance(op, ast.Sub):
        return '-'

    if isinstance(op, ast.Mult):
        return '*'

    if isinstance(op, ast.Div):
        return '/'

    if isinstance(op, ast.Mod):
        return '%'

def get_cmpop(op):
    # cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

    if isinstance(op, ast.Eq):
        return '=='

    if isinstance(op, ast.NotEq):
        return '!='

    if isinstance(op, ast.Lt):
        return '<'

    if isinstance(op, ast.LtE):
        return '<='

    if isinstance(op, ast.Gt):
        return '>'

    if isinstance(op, ast.GtE):
        return '>='

    if isinstance(op, ast.Is):
        return '=='

    if isinstance(op, ast.IsNot):
        return '!='

def get_func_returns(parsed):
    funcs = {}

    for obj in parsed.body:
        if isinstance(obj, ast.FunctionDef):
            func_name = obj.name

            if obj.returns is None:
                func_type = 'void'
            else:
                func_type = types[obj.returns.id]

            funcs[func_name] = func_type

    return funcs



def to_arduino(obj, result=None, newline=True):

    if result is None:
        result = result_template.copy()

    if obj == [] or obj is None:
        return result

    if isinstance(obj, list):
        to_arduino(obj[0], result, newline=newline)
        obj.pop(0)
        to_arduino(obj, result, newline=newline)

    elif isinstance(obj, ast.Name):
        return {'code': obj.id}

    elif isinstance(obj, ast.Num):
        return {'code': obj.n}

    elif isinstance(obj, ast.List):
        # create an actual list and get its type
        elts = [eval(to_arduino(elt)['code']) for elt in obj.elts]
        list_type = get_arduino_type(elts)
        code = ...

    elif isinstance(obj, ast.Module):
        result = to_arduino(obj.body, result, newline=newline)

    elif isinstance(obj, ast.FunctionDef):
        func_name = obj.name
        func_args = set()

        for arg in obj.args.args:
            arg_name = arg.arg
            arg_type = to_arduino(arg.annotation, newline=newline)['code']
            func_args.add((arg_name, arg_type))

        args_code = ''

        for n, arg in enumerate(func_args):
            if n + 1 < len(func_args):
                args_code += '{} {}, '.format(arg[1], arg[0])
            else:
                args_code += '{} {}'.format(arg[1], arg[0])

        if obj.returns is None:
            func_type = 'void'
        else:
            func_type = types[obj.returns.id]

        
        temp_result = result.copy()
        temp_result['code'] = ''
        to_arduino(obj.body, temp_result, newline=newline)
        body_code = temp_result['code']

        declaration_code = FUNC_DEF.format(type=func_type, name=func_name,
                                args=args_code)

        code = (declaration_code + ' {\n'
                 + body_code + '}\n')

        result['funcs'][func_name] = func_type
        result['variables']['local'] = {}
        result['code'] += code

        # hack for global variables
        result['global_declarations'] = temp_result.get('global_declarations')

        if func_name != 'setup' and func_name != 'loop':
            result['code'] = declaration_code + ';\n\n' + result['code']

    elif isinstance(obj, ast.Assign):
        var_name = obj.targets[0].id
        var_value = to_arduino(obj.value, newline=newline)['code']

        if isinstance(obj.value, ast.Call):
            var_type = result['funcs'][var_value.split('(')[0].lstrip()]
        elif isinstance(obj.value, (ast.List, ast.Tuple)):
            var_type = get_container_type(obj.value.elts)
        elif isinstance(obj.value, ast.BinOp):
            # temporary hack until I think of the best way of handling this
            var_type = 'int'
        else:
            var_type = get_arduino_type(var_value)

        var_value = str(var_value).lstrip()

        scope = 'global' if obj.col_offset is 0 else 'local'

        if var_name in result['variables'][scope]:
            code = VAR_REDEFINED.format(indent=calc_indent(obj), name=var_name,
             value=var_value)
        else:

            # if it's a pending global
            if var_name in result['variables']['pending_globals']:
                scope = 'global'

                # add it to the top if it isn't there

                if var_name not in result['variables']['global']:
                    declaration_code = '{} {}'.format(var_type, var_name)

                    # hack for the postprocessor
                    try:
                        result['global_declarations'].append(declaration_code)
                    except KeyError:
                        result['global_declarations'] = [declaration_code]

                    result['variables']['global'][var_name] = var_type

                code = VAR_REDEFINED.format(indent=calc_indent(obj), name=var_name,
             value=var_value)

                result['variables']['pending_globals'].remove(var_name)

            # if it's a fresh local declaration
            else:    
                code = VAR_NEW.format(indent=calc_indent(obj), type=var_type,
                 name=var_name, 
                    value=var_value)
        
        result['variables'][scope][var_name] = var_type

        result['code'] += code

    elif isinstance(obj, ast.AugAssign):
        var_name = obj.target.id
        op = get_operator(obj.op)
        var_value = str(to_arduino(obj.value, newline=newline)['code'])

        code = AUG_ASSIGN.format(indent=calc_indent(obj), name=var_name, 
                                    op=op, value=var_value)

        result['code'] += code

    elif isinstance(obj, ast.Expr):
        return to_arduino(obj.value, result, newline=newline)

    elif isinstance(obj, ast.Call):
        func_name = to_arduino(obj.func, newline=False)['code']

        if isinstance(obj.args[0], ast.Call):
            args_code = to_arduino(obj.args, newline=False)['code'].lstrip()

        else:
            args_code = ''
            for n, arg in enumerate(obj.args):
                if n + 1 < len(obj.args):
                    args_code += str(to_arduino(arg,
                                     newline=False)['code']).lstrip() + ', '
                else:
                    args_code += str(to_arduino(arg,
                                     newline=False)['code']).lstrip()

        code = FUNC_CALL.format(indent=calc_indent(obj), name=func_name, args=args_code)
        result['code'] += code

    elif isinstance(obj, ast.Attribute):
        class_name = to_arduino(obj.value,
         newline=False)['code'].lstrip()
        attribute_name = obj.attr

        code = '{}.{}'.format(class_name, attribute_name)

        return {'code': code} 

    elif isinstance(obj, ast.Str):
        if len(obj.s) is 1:
            code = "'{}'".format(obj.s)
        else:
            code = '"{}"'.format(obj.s)
        return {'code': code}

    elif isinstance(obj, ast.If):
        test_code = to_arduino(obj.test, newline=False)['code'].lstrip()
        body_code = to_arduino(obj.body)['code']
        try:
            orelse_code = to_arduino(obj.orelse[0])['code']
        except IndexError:
            orelse_code = to_arduino(obj.orelse)['code']

        if_code = (IF.format(indent=calc_indent(obj), test=test_code)
            + ' {\n' + body_code + 
            '{indent}}}\n'.format(indent=calc_indent(obj)))

        if len(obj.orelse) >= 1:
            if isinstance(obj.orelse[0], ast.If) and 'else if' not in orelse_code:
                orelse_code = orelse_code.replace('if', 'else if')
            else:
                orelse_code = '{indent}else {{\n{code}{indent}}}'.format(
                    indent=calc_indent(obj), code=orelse_code)

        code = if_code + orelse_code
        result['code'] += code

    elif isinstance(obj, ast.While):
        test_code = to_arduino(obj.test, newline=False)['code'].lstrip()
        body_code = to_arduino(obj.body)['code']
        try:
            orelse_code = to_arduino(obj.orelse[0])['code']

            # realign the indent
            orelse_code = orelse_code.split(calc_indent(obj.orelse[0]))[1]
        except IndexError:
            # there is no else case in the loop
            orelse_code = ''

        while_code = (WHILE.format(indent=calc_indent(obj), test=test_code)
                    + ' {\n' + body_code + 
                    '{indent}}}\n'.format(indent=calc_indent(obj)))

        code = while_code + orelse_code
        result['code'] += code

    elif isinstance(obj, ast.Compare):
        left = to_arduino(obj.left, newline=False)['code'].lstrip()
        
        if len(obj.ops) is 1:
            cmpop = get_cmpop(obj.ops[0])
        else:
            unsupported_syntax(
                'Comparisons with multiple operators are currently not supported',
                obj.lineno)

        if len(obj.comparators) is 1:
            comparator = str(to_arduino(obj.comparators[0],
             newline=False)['code']).lstrip()
        else:
            unsupported_syntax(
                'Comparisons with multiple operators are currently not supported',
                obj.lineno)

        code = CMPOP.format(left=left, cmpop=cmpop, comparator=comparator)
        return {'code': code}

    elif isinstance(obj, ast.Return):
        ret_value = to_arduino(obj.value, newline=newline)
        result['code'] += calc_indent(obj) + 'return ' + ret_value['code'].lstrip()

    elif isinstance(obj, ast.BinOp):
        left = to_arduino(obj.left, newline=newline)['code']
        right = to_arduino(obj.right, newline=newline)['code']
        op = get_operator(obj.op)

        code = BIN_OP.format(indent=calc_indent(obj),
            left=left, right=right, op=op)
        result['code'] += code

    elif isinstance(obj, ast.Import):
        newline = False

        modules = obj.names

        for module in modules:
            filename = module.name + '.py'
            translated = translate(open(filename).read())
            write_translation(translated['code'], module.name, 'hpp')

        result['code'] = ('#include ' + module.name + '.hpp' + 
                            '\n' + result['code'])

    elif isinstance(obj, ast.Global):
        newline = False
        pending_globals = set(obj.names)
        result['variables']['pending_globals'] = pending_globals

    elif isinstance(obj, ast.Pass):
        pass

    elif isinstance(obj, ast.Break):
        result['code'] += calc_indent(obj) + 'break'

    elif isinstance(obj, ast.Continue):
        result['code'] += calc_indent(obj) + 'continue'

    else:
        raise UnsupportedSyntaxError('{} syntax is currently not supported'.format(
            type(obj).__name__), obj.lineno)

    # hackety hack
    result['code'] = str(result['code'])

    if newline:
        result['code'] += '\n'

    return result

def postprocess(result):
    code = result['code']

    code = code.replace('True', 'true')
    code = code.replace('False', 'false')

    # hack to support global variables
    try:
        global_declarations = '\n'.join(result['global_declarations']) + '\n'
        code = global_declarations + code
    except (KeyError, TypeError):
        pass

    # add semicolons
    code = code.splitlines()
    code = [line.rstrip() for line in code]

    for n, line in enumerate(code):
        if (not (line.endswith('{') or line.endswith('}'))
            and not line.endswith(';') and len(line) > 0):
            line += ';\n'
        elif line.endswith('}'):
            line += '\n\n'
        elif len(line) > 0:
            line += '\n'
        code[n] = line

    code = ''.join(code)

    code = MESSAGE + '\n\n' + code

    return code

def translate(code):
    parsed = ast.parse(code)

    funcs = get_func_returns(parsed)
    result = result_template.copy()
    result['funcs'].update(funcs)

    to_arduino(parsed, result)

    result['code'] = postprocess(result)
    return result

def write_translation(translated, filename, extension='ino'):
    
    try:
        os.mkdir(sketchname)
    except OSError:
        pass

    if '/' in filename:
        filename = os.path.split(filename)[1]

    with open('{}/{}.{}'.format(sketchname, filename.split('.')[0], extension), 'w') as sketch:
        sketch.write(translated)

def make_make(sketchname):
    make = MAKE_STRUCTURE.format(
    sketch_folder=sketchname,
    port=args.port,
    board=args.board)

    with open(os.path.join(sketchname, 'Makefile'), 'w') as makefile:
        makefile.write(make)

def run_make(sketchname):
    if args.upload:
        subprocess.call(['make', 'upload', '-C', sketchname])
    else:
        subprocess.call(['make', '-C', sketchname])
    os.remove(os.path.join(sketchname, 'Makefile'))

def main():
    global sketchname
    sketchname = args.file.split('.py')[0].rsplit('/')[1]

    sketchfile = open(args.file)
    translated = translate(sketchfile.read())

    write_translation(translated['code'], sketchname)

    if args.compile:
        make_make(sketchname)
        run_make(sketchname)

if __name__ == '__main__':
    argp = ArgumentParser()
    argp.add_argument('file', type=str, help='file to parse')
    argp.add_argument('-v', '--verbose', action='store_true', default=False,
     help='verbose mode')
    argp.add_argument('-w', action='store_true', default=False, 
        help='suppress warnings')

    # options for compilation
    argp.add_argument('-c', '--compile', action='store_true', 
        default=False, help='compile the script')
    argp.add_argument('-b', '--board', type=str, default='uno', 
        help='board type to compile for')
    argp.add_argument('-p', '--port', default='/dev/ttyusb', type=str,
        help='arduino serial port')
    argp.add_argument('-u', '--upload', action='store_true', default=False, 
        help='upload the script to the board (works only if -c or --compile is specified')
    args = argp.parse_args()

    if args.w:
        simplefilter('ignore')

    main()
